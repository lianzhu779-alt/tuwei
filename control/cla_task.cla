/**
 * @file cla_task.cla
 * @brief CLA任务实现 - PFC控制算法加速
 * @details 本文件实现了运行在CLA(Control Law Accelerator)上的实时控制任务，
 *          主要功能包括：
 *          - 三相电压采样与相电压转换
 *          - Clarke变换（ABC -> αβ坐标系）
 *          - Park变换（αβ -> DQ0坐标系）
 *          - PWM占空比控制
 *          - 正负序分量提取
 * @date 2025
 */

//
// Included Files
//
#include <cla_shared.h>
#include <stdint.h>
#include "epwm.h"
#include "transforms.h"
// #include "abc_dq0_pos.h"  // 方式1需要，方式2不需要
// #include "abc_dq0_neg.h"  // 方式1需要，方式2不需要
#include "sogi_pll.h"

//
// Globals
//

/** @brief PWM占空比，范围0.1~0.9 */
float duty;

/** @brief CLA到CPU的相电压数据缓冲区，存放于CLA消息RAM */
#pragma DATA_SECTION(g_CLA_ClaToCpuPhaseData, "Cla1ToCpuMsgRAM");
volatile CLA_ClaToCpuPhaseData_t g_CLA_ClaToCpuPhaseData;

/** @brief CLA到CPU的DQ0坐标系数据缓冲区，存放于CLA消息RAM */
#pragma DATA_SECTION(g_CLA_ClaToCpuDQ0Data, "Cla1ToCpuMsgRAM");
volatile CLA_ClaToCpuDQ0Data_t g_CLA_ClaToCpuDQ0Data;

/** @brief CLA到CPU的PLL数据缓冲区，存放于CLA消息RAM */
#pragma DATA_SECTION(g_CLA_ClaToCpuPllData, "Cla1ToCpuMsgRAM");
volatile CLA_ClaToCpuPllData_t g_CLA_ClaToCpuPllData;

/** @brief SOGI-PLL对象，用于电网同步和频率跟踪 */
static SOGI_PLL g_sogiPll;

/**
 * @brief CLA任务1 - 三相电压采样与坐标变换（SOGI-PLL方式）
 * @details 执行流程：
 *          1. 读取三相线电压 V_AB, V_BC, V_CA
 *          2. 将线电压转换为相电压 Va, Vb, Vc
 *          3. Clarke变换：将三相静止坐标系(ABC)转换为两相静止坐标系(αβ)
 *          4. SOGI-PLL处理：滤波、锁相、频率跟踪、Park变换
 *          5. 直接使用SOGI-PLL内部的正负序分量（已滤波）
 *          6. 将结果传递到CPU消息RAM
 *
 * @note 由EPWM1触发，采样周期与PWM周期同步
 * @note 当前使用方式2：直接使用SOGI-PLL内部正负序分量
 *       优势：谐波抑制-40dB/decade，抗噪声能力强，计算效率高
 * @note 如需切换到方式1（传统ABC_DQ0），取消相关代码注释
 */
__attribute__((interrupt)) void Cla1Task1 ( void )
{
    __mdebugstop();

    // ========== 变量声明与初始化 ==========
    // 三相线电压（ADC采样值）
    float v_ab = g_CLA_CpuToClaAdcData.V_LL_AB;
    float v_bc = g_CLA_CpuToClaAdcData.V_LL_BC;
    float v_ca = g_CLA_CpuToClaAdcData.V_LL_CA;

    // 三相相电压
    float va = 0.0f, vb = 0.0f, vc = 0.0f;

    // αβ坐标系向量
    AlphaBeta_Vec phaseVec;

    // 角度与三角函数（方式1需要，方式2不需要）
    // float theta, sin_theta, cos_theta;

    // ========== 电压变换 ==========
    // 线电压转相电压
    line_to_phase_voltages(v_ab, v_bc, v_ca, &va, &vb, &vc);
    g_CLA_ClaToCpuPhaseData.V_Phase_A = va;
    g_CLA_ClaToCpuPhaseData.V_Phase_B = vb;
    g_CLA_ClaToCpuPhaseData.V_Phase_C = vc;

    // ========== Clarke变换与SOGI-PLL ==========
    // Clarke变换：ABC -> αβ
    clarke_amplitude(va, vb, vc, &phaseVec);

    // 运行SOGI-PLL（滤波、锁相、频率跟踪）
    // 注意：SOGI_PLL_run内部已经计算并缓存了sin/cos值
    SOGI_PLL_run(&g_sogiPll, phaseVec.alpha, phaseVec.beta);

    // 方式2：直接使用SOGI-PLL内部的正负序分量（已滤波，推荐）✅
    // 优势：
    //   1. SOGI内部已完成Park变换，避免重复计算
    //   2. SOGI滤波后的数据，谐波抑制能力强（-40dB/decade）
    //   3. 计算效率更高，节省约5-8个CLA周期
    g_CLA_ClaToCpuDQ0Data.D_axis = g_sogiPll.d_pos;     // 正序D轴（SOGI滤波）
    g_CLA_ClaToCpuDQ0Data.Q_axis = g_sogiPll.q_pos;     // 正序Q轴（SOGI滤波）
    g_CLA_ClaToCpuDQ0Data.Zero_axis = 0.0f;             // 零轴分量（三相平衡时为0）

    // ========== 传递PLL数据到CPU ==========
    g_CLA_ClaToCpuPllData.theta = g_sogiPll.theta;
    g_CLA_ClaToCpuPllData.freq = g_sogiPll.freq;
    g_CLA_ClaToCpuPllData.omega = g_sogiPll.omega;
    g_CLA_ClaToCpuPllData.d_pos = g_sogiPll.d_pos;
    g_CLA_ClaToCpuPllData.q_pos = g_sogiPll.q_pos;
    g_CLA_ClaToCpuPllData.d_neg = g_sogiPll.d_neg;
    g_CLA_ClaToCpuPllData.q_neg = g_sogiPll.q_neg;
    g_CLA_ClaToCpuPllData.is_locked = (float)SOGI_PLL_is_locked(&g_sogiPll, 0.5f);

    // ========== 中断处理 ==========
    // 清除中断标志
    EPWM_clearEventTriggerInterruptFlag(EPWM1_BASE);
}

/**
 * @brief CLA任务2 - PWM占空比更新
 * @details 功能：
 *          - 根据duty值更新EPWM1的比较值
 *          - 测试模式：占空比从0.1递增到0.9后循环
 * @note 由EPWM4触发，用于PWM波形生成
 * @warning 当前为测试代码，实际应用中应根据控制算法计算占空比
 */
__attribute__((interrupt))  void Cla1Task2 ( void )
{
    __mdebugstop();
    // 更新PWM比较值（占空比控制）
    EPWM_setCounterCompareValue(EPWM1_BASE, EPWM_COUNTER_COMPARE_A,
                                (uint16_t)(duty * EPWM1_PERIOD + 0.5f));

    // 测试代码：占空比递增
    duty += 0.1f;
    duty = (duty > 0.9f) ? 0.1f : duty;

    // 清除中断标志
    EPWM_clearEventTriggerInterruptFlag(EPWM4_BASE);
}

/**
 * @brief CLA任务3 - 预留
 * @details 当前未使用，预留给未来功能扩展
 */
__attribute__((interrupt))  void Cla1Task3 ( void )
{
}

/**
 * @brief CLA任务4 - 预留
 * @details 当前未使用，预留给未来功能扩展
 */
__attribute__((interrupt))  void Cla1Task4 ( void )
{
}

/**
 * @brief CLA任务5 - 预留
 * @details 当前未使用，预留给未来功能扩展
 */
__attribute__((interrupt))  void Cla1Task5 ( void )
{
}

/**
 * @brief CLA任务6 - 预留
 * @details 当前未使用，预留给未来功能扩展
 */
__attribute__((interrupt))  void Cla1Task6 ( void )
{
}

/**
 * @brief CLA任务7 - 预留
 * @details 当前未使用，预留给未来功能扩展
 */
__attribute__((interrupt))  void Cla1Task7 ( void )
{
}

/**
 * @brief CLA任务8 - 系统初始化与复位
 * @details 执行流程：
 *          1. 重置PWM占空比为初始值0.1
 *          2. 初始化SOGI-PLL（采样频率=100kHz，电网频率=50Hz）
 * @note 通常在系统启动或故障恢复时调用
 */
__attribute__((interrupt))  void Cla1Task8 ( void )
{
    // 重置占空比为初始值
    duty = 0.1f;

    // 重置坐标变换对象（方式1需要，方式2不需要）
    // ABC_DQ0_POS_reset(&g_abcDq0);
    // ABC_DQ0_NEG_reset(&g_abcDq0Neg);

    // 初始化SOGI-PLL
    // 参数：采样频率=EPWM1频率=100kHz，额定电网频率=50Hz
    // 注意：如果电网是60Hz，需要修改第二个参数为60.0f
    SOGI_PLL_init(&g_sogiPll, 16000.0f, 50.0f);

    // 可选：调整PLL增益以获得更好的动态响应
    // 参数：kp, ki, kb（kb通常等于ki）
    // SOGI_PLL_set_gains(&g_sogiPll, 150.0f, 8000.0f, 8000.0f);  // 更快响应
    // SOGI_PLL_set_gains(&g_sogiPll, 50.0f, 2000.0f, 2000.0f);   // 更平滑滤波
}

//
// End of File
//


