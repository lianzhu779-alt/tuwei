/**
 * @file cla_task.cla
 * @brief CLA任务实现 - PFC控制算法加速
 * @details 本文件实现了运行在CLA(Control Law Accelerator)上的实时控制任务，
 *          主要功能包括：
 *          - 三相电压采样与相电压转换
 *          - Clarke变换（ABC -> αβ坐标系）
 *          - Park变换（αβ -> DQ0坐标系）
 *          - PWM占空比控制
 *          - 正负序分量提取
 * @date 2025
 */

//
// Included Files
//
#include <cla_shared.h>
#include <stdint.h>
#include "board.h"
#include "epwm.h"
#include "transforms.h"
#include "sogi_pll.h"

//
// 前馈电流环配置
//
#define CLA_CONTROL_TS              (1.0f / 16000.0f)
#define CLA_VDC_REF_V               760.0f
#define CLA_VLOOP_KP                0.02f
#define CLA_VLOOP_KI                5.0f
#define CLA_IL_KP                   0.18f
#define CLA_IL_KI                   32.0f
#define CLA_ID_LIMIT_A              45.0f
#define CLA_VCMD_LIMIT_V            (0.45f * CLA_VDC_REF_V)
#define CLA_GRID_V_PEAK_BASE        325.0f
#define CLA_VOLTAGE_NORM_GAIN       (1.0f / CLA_GRID_V_PEAK_BASE)
#define CLA_MIN_VDC_FOR_MOD         100.0f
#define CLA_DUTY_MIN                0.05f
#define CLA_DUTY_MAX                0.95f

typedef struct
{
    float voltageLoopIntegral;  // 直流母线电压外环积分项
    float idIntegral;           // d轴电流环积分项
    float iqIntegral;           // q轴电流环积分项
} PFC_CurrentLoopState_t;

static PFC_CurrentLoopState_t g_currentLoopState; // CLA侧电流环状态缓存（任务8中复位）


//
// Globals
//

/** @brief CLA到CPU的相电压数据缓冲区，存放于CLA消息RAM */
#pragma DATA_SECTION(g_CLA_ClaToCpuPhaseData, "Cla1ToCpuMsgRAM");
volatile CLA_ClaToCpuPhaseData_t g_CLA_ClaToCpuPhaseData;

/** @brief CLA到CPU的DQ0坐标系数据缓冲区，存放于CLA消息RAM */
#pragma DATA_SECTION(g_CLA_ClaToCpuDQ0Data, "Cla1ToCpuMsgRAM");
volatile CLA_ClaToCpuDQ0Data_t g_CLA_ClaToCpuDQ0Data;

/** @brief CLA到CPU的PLL数据缓冲区，存放于CLA消息RAM */
#pragma DATA_SECTION(g_CLA_ClaToCpuPllData, "Cla1ToCpuMsgRAM");
volatile CLA_ClaToCpuPllData_t g_CLA_ClaToCpuPllData;

/** @brief SOGI-PLL对象，用于电网同步和频率跟踪 */
static SOGI_PLL g_sogiPll;

/**
 * @brief CLA任务1 - 三相电压采样与坐标变换（SOGI-PLL方式）
 * @details 执行流程：
 *          1. 读取三相线电压 V_AB, V_BC, V_CA
 *          2. 将线电压转换为相电压 Va, Vb, Vc
 *          3. Clarke变换：将三相静止坐标系(ABC)转换为两相静止坐标系(αβ)
 *          4. SOGI-PLL处理：滤波、锁相、频率跟踪、Park变换
 *          5. 直接使用SOGI-PLL内部的正负序分量（已滤波）
 *          6. 将结果传递到CPU消息RAM
 *
 * @note 由EPWM1触发，采样周期与PWM周期同步
 * @note 直接使用SOGI-PLL内部正负序分量
 *       优势：谐波抑制-40dB/decade，抗噪声能力强，计算效率高
 */

__attribute__((interrupt)) void Cla1Task1 ( void )
{
    __mdebugstop();
    // 调试构建下在此停住CLA，便于单步查看消息RAM与寄存器

    // ========== 变量声明与初始化 ==========
    float v_ab = g_CLA_CpuToClaAdcData.V_LL_AB; // 三相线电压（相继变换前）
    float v_bc = g_CLA_CpuToClaAdcData.V_LL_BC;
    float v_ca = g_CLA_CpuToClaAdcData.V_LL_CA;
    // 线电压采样值已经在CPU侧做过标定与滤波，单位默认为伏

    float va = 0.0f, vb = 0.0f, vc = 0.0f;
    // 先清零相电压变量，防止上一周期残留值影响本次计算

    AlphaBeta_Vec phaseVec;
    // phaseVec保存电压αβ矢量，供PLL与SVPWM链路共享
    AlphaBeta_Vec currentVec;
    // currentVec保存电流αβ矢量，供电流环的Park变换使用

    // ========== 电压变换 ==========
    line_to_phase_voltages(v_ab, v_bc, v_ca, &va, &vb, &vc);
    // 线->相变换假设系统三相对称，异常分量将在SOGI及dq环中被抑制
    g_CLA_ClaToCpuPhaseData.V_Phase_A = va;
    g_CLA_ClaToCpuPhaseData.V_Phase_B = vb;
    g_CLA_ClaToCpuPhaseData.V_Phase_C = vc;
    // 结果实时写入消息RAM，CPU侧波形监测/保护逻辑可立即读取

    // ========== Clarke变换与SOGI-PLL ==========
    clarke_amplitude(va, vb, vc, &phaseVec); // 把三相电压映射到αβ坐标
    // Clarke幅值保持算法确保αβ矢量幅值与物理测量一致

    SOGI_PLL_run(&g_sogiPll, phaseVec.alpha, phaseVec.beta); // 完成滤波、锁相、正负序提取
    // 一次SOGI-PLL运行即可获得锁相角度、sin/cos以及正负序电压

    float sin_theta = SOGI_PLL_get_sin_theta(&g_sogiPll);
    float cos_theta = SOGI_PLL_get_cos_theta(&g_sogiPll);
    float pll_locked_flag = (float)SOGI_PLL_is_locked(&g_sogiPll, 0.5f);
    // 锁定标志同步给电流环以及CPU端做并网判断

    // ========== 三相电流采样并转换 ==========
    float ia = g_CLA_CpuToClaAdcData.I_Phase_A;
    float ib = g_CLA_CpuToClaAdcData.I_Phase_B;
    float ic = g_CLA_CpuToClaAdcData.I_Phase_C;
    clarke_amplitude(ia, ib, ic, &currentVec);
    // 电流经Clarke后移除零序，可直接进入Park变换

    float i_d = 0.0f;
    float i_q = 0.0f;
    Park_transform_positive_fast(currentVec.alpha, currentVec.beta,
                                 cos_theta, sin_theta, &i_d, &i_q);
    // 得到的i_d/i_q分别调有功与无功，支撑解耦电流环

    float vdc_meas = g_CLA_CpuToClaAdcData.V_DC800_Total;
    float vdc_error = CLA_VDC_REF_V - vdc_meas;
    // 电压误差驱动外环，保持母线电压稳定

    g_currentLoopState.voltageLoopIntegral += CLA_VLOOP_KI * CLA_CONTROL_TS * vdc_error; // 母线电压外环
    // 外环积分器累积误差，并结合后续饱和保护避免积分发散
    g_currentLoopState.voltageLoopIntegral =
        saturate_inline(g_currentLoopState.voltageLoopIntegral, -CLA_ID_LIMIT_A, CLA_ID_LIMIT_A);

    float id_amplitude = CLA_VLOOP_KP * vdc_error + g_currentLoopState.voltageLoopIntegral;
    // 正序电流幅值命令
    id_amplitude = saturate_inline(id_amplitude, -CLA_ID_LIMIT_A, CLA_ID_LIMIT_A);

    if (pll_locked_flag < 0.5f)
    // PLL未锁定时清除各积分项，防止误差堆积拉偏直流母线
    {
        g_currentLoopState.voltageLoopIntegral = 0.0f; // 防止未锁定时积分漂移
        g_currentLoopState.idIntegral = 0.0f;
        g_currentLoopState.iqIntegral = 0.0f;
        id_amplitude = 0.0f;
    }

    // 外环输出直接作为d轴电流参考，去掉dq轴归一化
    float id_ref = id_amplitude;
    float iq_ref = 0.0f;
    // PFC默认不送无功功率，因此q轴参考保持为0

    float id_err = id_ref - i_d;
    g_currentLoopState.idIntegral += CLA_IL_KI * CLA_CONTROL_TS * id_err; // d轴电流环积分
    // d轴PI积分带限，兼顾快速性与防超调
    g_currentLoopState.idIntegral =
        saturate_inline(g_currentLoopState.idIntegral, -CLA_VCMD_LIMIT_V, CLA_VCMD_LIMIT_V);
    float vd_ctrl = CLA_IL_KP * id_err + g_currentLoopState.idIntegral;

    float iq_err = iq_ref - i_q;
    g_currentLoopState.iqIntegral += CLA_IL_KI * CLA_CONTROL_TS * iq_err;
    // q轴积分同样受限，防止PLL短时震荡导致积分累积
    g_currentLoopState.iqIntegral =
        saturate_inline(g_currentLoopState.iqIntegral, -CLA_VCMD_LIMIT_V, CLA_VCMD_LIMIT_V);
    float vq_ctrl = CLA_IL_KP * iq_err + g_currentLoopState.iqIntegral;

    float vd_cmd = vd_ctrl + g_sogiPll.d_pos;
    float vq_cmd = vq_ctrl + g_sogiPll.q_pos;

    AlphaBeta_Vec voltageCmd;
    inverse_park(vd_cmd, vq_cmd, cos_theta, sin_theta, &voltageCmd);
    // 将dq调制电压旋转回αβ坐标，为SVPWM做准备

    float va_cmd, vb_cmd, vc_cmd;
    inverse_clarke(voltageCmd.alpha, voltageCmd.beta, &va_cmd, &vb_cmd, &vc_cmd);
    // 再从αβ变换回abc三相，得到每相指令电压

    // ========== SVPWM零序注入 ========== 
    float vdc_safe = (vdc_meas > CLA_MIN_VDC_FOR_MOD) ? vdc_meas : CLA_MIN_VDC_FOR_MOD;
    float inv_vdc = 2.0f / vdc_safe;             // 归一化到Vdc/2

    // 归一化相电压
    float v_a = va_cmd * inv_vdc;
    // 归一化到[-1,1]区间，方便后续min-max零序注入
    float v_b = vb_cmd * inv_vdc;
    float v_c = vc_cmd * inv_vdc;

    // min-max 中点零序注入
    float v_max = v_a;
    if (v_b > v_max) v_max = v_b;
    if (v_c > v_max) v_max = v_c;
    float v_min = v_a;
    if (v_b < v_min) v_min = v_b;
    if (v_c < v_min) v_min = v_c;
    float v_offset = -0.5f * (v_max + v_min);
    // min-max注入的零序量，可最大化调制比并抑制饱和

    float v_a_mod = saturate_inline(v_a + v_offset, -1.0f, 1.0f);
    float v_b_mod = saturate_inline(v_b + v_offset, -1.0f, 1.0f);
    float v_c_mod = saturate_inline(v_c + v_offset, -1.0f, 1.0f);

    // 线性映射到占空比
    float duty_a = saturate_inline(0.5f + 0.5f * v_a_mod, CLA_DUTY_MIN, CLA_DUTY_MAX);
    float duty_b = saturate_inline(0.5f + 0.5f * v_b_mod, CLA_DUTY_MIN, CLA_DUTY_MAX);
    float duty_c = saturate_inline(0.5f + 0.5f * v_c_mod, CLA_DUTY_MIN, CLA_DUTY_MAX);
    // 将归一化电压线性映射到占空比，附带上下限保护

    uint16_t cmpA = (uint16_t)(duty_a * (float)PFC_A_TBPRD + 0.5f);
    uint16_t cmpB = (uint16_t)(duty_b * (float)PFC_B_TBPRD + 0.5f);
    uint16_t cmpC = (uint16_t)(duty_c * (float)PFC_C_TBPRD + 0.5f);

    EPWM_setCounterCompareValue(PFC_A_BASE, EPWM_COUNTER_COMPARE_A, cmpA);
    EPWM_setCounterCompareValue(PFC_B_BASE, EPWM_COUNTER_COMPARE_A, cmpB);
    EPWM_setCounterCompareValue(PFC_C_BASE, EPWM_COUNTER_COMPARE_A, cmpC);

    // ========== 计算结果推送CPU ==========
    g_CLA_ClaToCpuDQ0Data.D_axis = i_d;
    g_CLA_ClaToCpuDQ0Data.Q_axis = i_q;
    g_CLA_ClaToCpuDQ0Data.Zero_axis = id_ref;
    // Zero轴暂存id参考值，CPU可据此监控功率命令

    g_CLA_ClaToCpuPllData.theta = g_sogiPll.theta;
    g_CLA_ClaToCpuPllData.freq = g_sogiPll.freq;
    g_CLA_ClaToCpuPllData.omega = g_sogiPll.omega;
    g_CLA_ClaToCpuPllData.d_pos = g_sogiPll.d_pos;
    g_CLA_ClaToCpuPllData.q_pos = g_sogiPll.q_pos;
    g_CLA_ClaToCpuPllData.d_neg = g_sogiPll.d_neg;
    g_CLA_ClaToCpuPllData.q_neg = g_sogiPll.q_neg;
    g_CLA_ClaToCpuPllData.is_locked = pll_locked_flag;
    // CPU通过该标志判断PLL同步状态，触发保护或并网逻辑

    EPWM_clearEventTriggerInterruptFlag(EPWM1_BASE);
    // 清除触发标志，等待下一次EPWM比较事件唤醒本任务
}

__attribute__((interrupt))  void Cla1Task2 ( void )
{
    __mdebugstop();
    // PWM占空比由Task1前馈电流环实时更新，此处仅保留中断响应
    EPWM_clearEventTriggerInterruptFlag(EPWM4_BASE);
}
__attribute__((interrupt))  void Cla1Task3 ( void )
{
}

/**
 * @brief CLA任务4 - 预留
 * @details 当前未使用，预留给未来功能扩展
 */
__attribute__((interrupt))  void Cla1Task4 ( void )
{
}

/**
 * @brief CLA任务5 - 预留
 * @details 当前未使用，预留给未来功能扩展
 */
__attribute__((interrupt))  void Cla1Task5 ( void )
{
}

/**
 * @brief CLA任务6 - 预留
 * @details 当前未使用，预留给未来功能扩展
 */
__attribute__((interrupt))  void Cla1Task6 ( void )
{
}

/**
 * @brief CLA任务7 - 预留
 * @details 当前未使用，预留给未来功能扩展
 */
__attribute__((interrupt))  void Cla1Task7 ( void )
{
}

/**
 * @brief CLA任务8 - 系统初始化与复位
 * @details 执行流程：
 *          1. 重置PWM占空比为初始值0.1
 *          2. 初始化SOGI-PLL（采样频率=100kHz，电网频率=50Hz）
 * @note 通常在系统启动或故障恢复时调用
 */
__attribute__((interrupt))  void Cla1Task8 ( void )
{
    // 重置占空比为初始值
    g_currentLoopState.voltageLoopIntegral = 0.0f;
    g_currentLoopState.idIntegral = 0.0f;
    g_currentLoopState.iqIntegral = 0.0f;

    // 初始化SOGI-PLL
    // 参数：采样频率=EPWM1频率=16kHz，额定电网频率=50Hz
    // 注意：如果电网是60Hz，需要修改第二个参数为60.0f
    SOGI_PLL_init(&g_sogiPll, 16000.0f, 50.0f);

    // 可选：调整PLL增益以获得更好的动态响应
    // 参数：kp, ki, kb（kb通常等于ki）
    // SOGI_PLL_set_gains(&g_sogiPll, 150.0f, 8000.0f, 8000.0f);  // 更快响应
    // SOGI_PLL_set_gains(&g_sogiPll, 50.0f, 2000.0f, 2000.0f);   // 更平滑滤波
}

//
// End of File
//


